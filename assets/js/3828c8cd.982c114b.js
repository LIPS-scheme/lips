"use strict";(self.webpackChunknew_docs=self.webpackChunknew_docs||[]).push([[1208],{6388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>h});var s=t(5893),a=t(1151);const r={slug:"emacs-scheme-regex",title:"Scheme Regex literals in Emacs",authors:"jcubic",tags:["scheme","emacs"]},o=void 0,i={permalink:"/blog/emacs-scheme-regex",editUrl:"https://github.com/jcubic/lips/tree/master/docs/blog/2024-03-09-emacs-regex-literals.md",source:"@site/blog/2024-03-09-emacs-regex-literals.md",title:"Scheme Regex literals in Emacs",description:"LIPS Scheme support regular expression literals, but it's not the only one implementation that",date:"2024-03-09T00:00:00.000Z",formattedDate:"March 9, 2024",tags:[{label:"scheme",permalink:"/blog/tags/scheme"},{label:"emacs",permalink:"/blog/tags/emacs"}],readingTime:2.27,hasTruncateMarker:!0,authors:[{name:"Jakub T. Jankiewicz",title:"LIPS maintainer",url:"https://jakub.jankiewicz.org/",imageURL:"https://github.com/jcubic.png",key:"jcubic"}],frontMatter:{slug:"emacs-scheme-regex",title:"Scheme Regex literals in Emacs",authors:"jcubic",tags:["scheme","emacs"]},unlisted:!1,nextItem:{title:"LIPS History",permalink:"/blog/lips-history"}},c={authorsImageUrls:[void 0]},h=[{value:"The problem",id:"the-problem",level:2},{value:"The solution",id:"the-solution",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["LIPS Scheme support regular expression literals, but it's not the only one implementation that\nsupport those.  Other implementation includes ",(0,s.jsx)(n.a,{href:"https://practical-scheme.net/gauche/",children:"Gauche"})," and\n",(0,s.jsx)(n.a,{href:"https://www.gnu.org/software/kawa/index.html",children:"Kawa"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Unfortunetlly, you can't easily use those regular expressions in ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/GNU_Emacs",children:"GNU\nEmacs"}),", my main editor of choice."]}),"\n",(0,s.jsx)(n.h2,{id:"the-problem",children:"The problem"}),"\n",(0,s.jsxs)(n.p,{children:["The main problem is when using vertical bar character inside Scheme code in Emacs. GNU Emacs thinks\nthat the vertical bar is part of the ",(0,s.jsx)(n.a,{href:"/docs/scheme-intro/data-types#symbols",children:"symbol"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scheme",children:'(let ((str "foo bar")\n      (re #/foo|bar/)) ;; | ))\n  (str.match re))\n;; ==> #("foo")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This blog (the same as whole website) use modified PrismJS Scheme mode that supports regular\nexpressions. But in GNU Emacs there was a need to add ",(0,s.jsx)(n.code,{children:"|"})," after a comment and close the lists that\nwere ignored by Emacs scheme mode (because they were inside symbol)."]}),"\n",(0,s.jsx)(n.h2,{id:"the-solution",children:"The solution"}),"\n",(0,s.jsxs)(n.p,{children:["I asked a ",(0,s.jsx)(n.a,{href:"https://lists.gnu.org/archive/html/emacs-devel/2024-02/msg00896.html",children:"question on emacs-devel mailing\nlist"}),", on how to solve this\nproblem. I didn't get any reply for days, then suddenly someone ",(0,s.jsx)(n.a,{href:"https://lists.gnu.org/archive/html/emacs-devel/2024-03/msg00282.html",children:"reply with this emacs lisp code\nsnippet"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(defun scheme-regex-patch ()\n  (setq-local\n   syntax-propertize-function\n   (lambda (start end)\n     (goto-char start)\n     (funcall\n      (syntax-propertize-rules\n       ;; For #/regexp/ syntax\n       ("\\\\(#\\\\)/\\\\(\\\\\\\\/\\\\|\\\\\\\\\\\\\\\\\\\\|.\\\\)*?\\\\(/\\\\)"\n        (1 "|")\n        (3 "|"))\n       ;; For #; comment syntax\n       ("\\\\(#\\\\);"\n        (1 (prog1 "< cn"\n             (scheme-syntax-propertize-sexp-comment\n              (point) end)))))\n      (point) end))))\n\n(add-hook \'scheme-mode-hook \'scheme-regex-patch)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This solution worked great, until I've found that it don't properly handle Scheme expression\ncomments ",(0,s.jsx)(n.code,{children:"#;"}),", that are part of the solution. In the meantime on the mailing list there was discussion\nabout this feature (probably becase it's part of GNU Kawa) to integrate with builtin ",(0,s.jsx)(n.code,{children:"scheme.el"}),".\nSo soon you may not need a hack like this when working with regular expressions."]}),"\n",(0,s.jsx)(n.p,{children:"This is a proposed solution after I said that the code doesn't work for Scheme expression comments."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(defun scheme-regex-patch ()\n   (setq-local\n    syntax-propertize-function\n    (lambda (beg end)\n      (goto-char beg)\n      (scheme-syntax-propertize-sexp-comment2 end)\n      (scheme-syntax-propertize-regexp end)\n      (funcall\n       (syntax-propertize-rules\n        ("\\\\(#\\\\);" (1 (prog1 "< cn"\n                         (scheme-syntax-propertize-sexp-comment2 end))))\n        ("\\\\(#\\\\)/" (1 (when (null (nth 8 (save-excursion\n                                            (syntax-ppss\n                                             (match-beginning 0)))))\n                         (put-text-property\n                          (match-beginning 1)\n                          (match-end 1)\n                          \'syntax-table (string-to-syntax "|"))\n                         (scheme-syntax-propertize-regexp end)\n                         nil)\n                       )))\n       (point) end))))\n\n(defun scheme-syntax-propertize-sexp-comment2 (end)\n  (let ((state (syntax-ppss)))\n    (when (eq 2 (nth 7 state))\n      ;; It\'s a sexp-comment.  Tell parse-partial-sexp where it ends.\n      (condition-case nil\n          (progn\n            (goto-char (+ 2 (nth 8 state)))\n            ;; FIXME: this doesn\'t handle the case where the sexp\n            ;; itself contains a #; comment.\n            (forward-sexp 1)\n            (put-text-property (1- (point)) (point)\n                               \'syntax-table (string-to-syntax "> cn")))\n        (scan-error (goto-char end))))))\n\n(defun scheme-syntax-propertize-regexp (end)\n  (let* ((state (syntax-ppss))\n         (within-str (nth 3 state))\n         (start-delim-pos (nth 8 state)))\n    (when (and within-str\n               (char-equal ?# (char-after start-delim-pos)))\n      (while\n          (and\n           (re-search-forward "/" end \'move)\n           (eq -1\n               (% (save-excursion\n                    (backward-char)\n                    (skip-chars-backward "\\\\\\\\")) 2))))\n      (when (< (point) end)\n        (progn\n          (put-text-property\n           (match-beginning 0)\n           (match-end 0)\n           \'syntax-table (string-to-syntax "|")))))))\n\n(add-hook \'scheme-mode-hook \'scheme-regex-patch)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You can read the whole discussion on ",(0,s.jsx)(n.a,{href:"https://lists.gnu.org/archive/html/emacs-devel/2024-03/msg00590.html",children:"emacs-devel mailing list archive"}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>o});var s=t(7294);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);