"use strict";(self.webpackChunknew_docs=self.webpackChunknew_docs||[]).push([[8691],{1621:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>l,frontMatter:()=>c,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"scheme-intro/streams","title":"Streams","description":"Feature of scheme that allow to create lazy lists","source":"@site/docs/scheme-intro/streams.md","sourceDirName":"scheme-intro","slug":"/scheme-intro/streams","permalink":"/docs/scheme-intro/streams","draft":false,"unlisted":false,"editUrl":"https://github.com/LIPS-scheme/lips/tree/master/docs/docs/scheme-intro/streams.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"Feature of scheme that allow to create lazy lists"},"sidebar":"tutorialSidebar","previous":{"title":"Macros","permalink":"/docs/scheme-intro/macros"},"next":{"title":"Continuations","permalink":"/docs/scheme-intro/continuations"}}');var a=n(4848),t=n(8453);const c={sidebar_position:6,description:"Feature of scheme that allow to create lazy lists"},i="Streams",o={},m=[];function d(e){const s={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"streams",children:"Streams"})}),"\n",(0,a.jsxs)(s.p,{children:["Streams (also called delayed Lists or lazy lists) are a data structure described in\n",(0,a.jsx)(s.a,{href:"https://web.mit.edu/6.001/6.037/sicp.pdf",children:"SICP"})," Chapter 3.5. It also appears in Chapter 21 of\n",(0,a.jsx)(s.a,{href:"https://people.cs.aau.dk/~normark/prog3-03/html/notes/eval-order_themes-delay-stream-section.html",children:"Functional Programming in Scheme"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["The base of those data structures are two expressions ",(0,a.jsx)(s.code,{children:"delay"})," and ",(0,a.jsx)(s.code,{children:"force"}),"."]}),"\n",(0,a.jsx)(s.p,{children:"The result of a delay is often called a Promise."}),"\n",(0,a.jsxs)(s.p,{children:["To create a lazy ",(0,a.jsx)(s.a,{href:"/docs/scheme-intro/data-types#pairs",children:"pair"}),", you use cons with the first element\n(",(0,a.jsx)(s.code,{children:"car"}),") and the rest (",(0,a.jsx)(s.code,{children:"cdr"}),") is a delay expression:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define s (cons 1 (delay 2)))\n"})}),"\n",(0,a.jsx)(s.p,{children:"If you print this expression, you will get something like this (it depends on Scheme implementation)"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(write (cons 1 (delay 2)))\n;; ==> (1 . #<promise - not forced>)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"cdr"})," is a promise that needs to be forced to get evaluated."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(let ((x (cons 1 (delay 2))))\n  (write (force (cdr x)))\n  (newline)\n  (write x)\n  (newline))\n;; ==> 2\n;; ==> (1 . #<promise - forced with number>)\n"})}),"\n",(0,a.jsx)(s.p,{children:"With this you can create infinite lists because the delay can point into the same object."}),"\n",(0,a.jsx)(s.p,{children:"Let's define some helper procedures:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define-macro (stream-cons x y)\n  `(cons ,x (delay ,y)))\n"})}),"\n",(0,a.jsxs)(s.p,{children:["This is lazy version of cons that utilize ",(0,a.jsx)(s.a,{href:"/docs/scheme-intro/macros",children:"lisp macro"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["You can also define ",(0,a.jsx)(s.code,{children:"car"})," and ",(0,a.jsx)(s.code,{children:"cdr"})," versions that work with streams:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-car stream)\n  (car stream))\n\n(define (stream-cdr stream)\n  (force (cdr stream)))\n"})}),"\n",(0,a.jsx)(s.p,{children:"stream-car is the same as car so you can use an alias:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define stream-car car)\n"})}),"\n",(0,a.jsx)(s.p,{children:"We also need an empty stream and predicate that check if stream is empty:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (empty-stream? x) (eq? x the-empty-stream))\n(define the-empty-stream '())\n"})}),"\n",(0,a.jsx)(s.p,{children:"To create an infinite stream of ones, you can use code like this:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define ones (stream-cons 1 ones))\n(write (stream-car (stream-cdr (stream-cdr ones))))\n;; ==> 1\n"})}),"\n",(0,a.jsx)(s.p,{children:"Let's write a procedure that take a stream and return a list of first n elements."}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-take n stream)\n  (if (<= n 0)\n      '()\n      (cons (stream-car stream) (stream-take (- n 1) (stream-cdr stream)))))\n\n\n(write (stream-take 10 ones))\n;; ==> (1 1 1 1 1 1 1 1 1 1)\n"})}),"\n",(0,a.jsx)(s.p,{children:"You can define procedures that operate on streams, like procedure that add two streams:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-add s1 s2)\n  (let ((first-a (stream-car s1))\n        (first-b (stream-car s2)))\n    (stream-cons\n     (+ first-a first-b)\n     (add-streams (stream-cdr s1) (stream-cdr s2)))))\n"})}),"\n",(0,a.jsx)(s.p,{children:"You can sue this function to create stream of integers:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define integers (stream-cons 1 (stream-add integers ones)))\n"})}),"\n",(0,a.jsxs)(s.p,{children:["To prove that it works, you can get first 10 elements with ",(0,a.jsx)(s.code,{children:"stream-take"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(display (stream-take 10 integers))\n;; ==> (1 2 3 4 5 6 7 8 9 10)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["We can also define higher order procedures that operate on streams. They will not execute until you\nuse ",(0,a.jsx)(s.code,{children:"force"}),". Example cam be ",(0,a.jsx)(s.code,{children:"stream-map"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-map proc . streams)\n  (define (single-map proc stream)\n    (if (empty-stream? stream)\n        the-empty-stream\n        (stream-cons (apply proc (stream-car stream))\n                     (single-map proc (stream-cdr stream)))))\n  (single-map proc (apply stream-zip streams)))\n"})}),"\n",(0,a.jsx)(s.p,{children:"It requires helper procedure that combine two streams by taking each element from every stream and\ncreates a single list in output stream."}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-zip . streams)\n  (if (empty-stream? streams)\n      the-empty-stream\n      (stream-cons (apply list (map stream-car streams))\n                   (apply stream-zip (map stream-cdr streams)))))\n"})}),"\n",(0,a.jsx)(s.p,{children:"The function work like this:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(stream-take 5 (stream-zip integers integers ones))\n;; ==> ((1 1 1) (2 2 1) (3 3 1) (4 4 1) (5 5 1))\n"})}),"\n",(0,a.jsxs)(s.p,{children:["With map, you can simplify ",(0,a.jsx)(s.code,{children:"stream-add"})," with ",(0,a.jsx)(s.code,{children:"stream-map"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (streams-add s1 s2)\n  (stream-map + s1 s2))\n"})}),"\n",(0,a.jsx)(s.p,{children:"Another useful procedures that accept stream are stream-limit and force-stream:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-limit n stream)\n  (let loop ((n n) (stream stream))\n    (if (or (empty-stream? stream) (= n 0))\n        the-empty-stream\n        (stream-cons (stream-car stream)\n                     (loop (- n 1)\n                           (stream-cdr stream))))))\n\n(define (stream-force stream)\n  (let loop ((stream stream))\n    (if (empty-stream? stream)\n        '()\n        (cons (stream-car stream)\n              (loop (stream-cdr stream))))))\n"})}),"\n",(0,a.jsxs)(s.p,{children:["If you call ",(0,a.jsx)(s.code,{children:"force-stream"})," on infinite stream it will create infinite loop, but note that the\nprocedure force-stream is not tail recursive. The recursive call to named ",(0,a.jsx)(s.code,{children:"let"})," is not the last\nexpression. The last expression is ",(0,a.jsx)(s.code,{children:"cons"}),"."]}),"\n",(0,a.jsx)(s.p,{children:"You can try to create a tail recursive version of the procedure as an exercise."}),"\n",(0,a.jsxs)(s.p,{children:["If you combine both procedures, you can create the same effect as with ",(0,a.jsx)(s.code,{children:"stream-take"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(stream-force (stream-limit 10 integers))\n;; ==> (1 2 3 4 5 6 7 8 9 10)\n"})}),"\n",(0,a.jsx)(s.p,{children:"So you can implement stream-take with above procedures:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-take n stream)\n  (stream-force (stream-limit n stream)))\n\n(stream-take 10 integers)\n;; ==> (1 2 3 4 5 6 7 8 9 10)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Another useful procedure is ",(0,a.jsx)(s.code,{children:"stream-reduce"})," in Scheme often called ",(0,a.jsx)(s.code,{children:"fold"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (stream-reduce fun stream)\n  (let loop ((result (stream-car stream))\n             (stream (stream-cdr stream)))\n    (if (empty-stream? stream)\n        result\n        (loop (fun result (stream-car stream))\n              (stream-cdr stream)))))\n"})}),"\n",(0,a.jsx)(s.p,{children:"You can implement factorial function using streams:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define (! n)\n  (stream-reduce * (stream-limit n integers)))\n\n(! 10)\n;; ==> 3628800\n"})}),"\n",(0,a.jsx)(s.p,{children:"and you can use this procedure to create a stream of factorials:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define factorials\n  (stream-map ! integers))\n\n(stream-take 10 factorials)\n;; ==> (1 2 6 24 120 720 5040 40320 362880 3628800)\n"})}),"\n",(0,a.jsx)(s.p,{children:"Another example of using streams is calculation of Fibonacci numbers:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scheme",children:"(define fibs\n  (cons-stream 0\n               (cons-stream 1\n                            (add-streams (stream-cdr fibs) fibs))))\n\n(stream-take 10 fibs)\n;; ==> (0 1 1 2 3 5 8 13 21 34)\n"})})]})}function l(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>i});var r=n(6540);const a={},t=r.createContext(a);function c(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);