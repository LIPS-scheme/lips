"use strict";(self.webpackChunknew_docs=self.webpackChunknew_docs||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"emacs-scheme-regex","metadata":{"permalink":"/blog/emacs-scheme-regex","editUrl":"https://github.com/LIPS-scheme/lips/tree/master/docs/blog/2024-03-09-emacs-regex-literals.md","source":"@site/blog/2024-03-09-emacs-regex-literals.md","title":"Scheme Regex literals in Emacs","description":"LIPS Scheme support regular expression literals, but it\'s not the only one implementation that","date":"2024-03-09T00:00:00.000Z","tags":[{"inline":true,"label":"scheme","permalink":"/blog/tags/scheme"},{"inline":true,"label":"emacs","permalink":"/blog/tags/emacs"}],"readingTime":2.27,"hasTruncateMarker":true,"authors":[{"name":"Jakub T. Jankiewicz","title":"LIPS maintainer","url":"https://jakub.jankiewicz.org/","imageURL":"https://github.com/jcubic.png","key":"jcubic","page":null}],"frontMatter":{"slug":"emacs-scheme-regex","title":"Scheme Regex literals in Emacs","authors":"jcubic","image":"/img/emacs-scheme-regex.png","tags":["scheme","emacs"]},"unlisted":false,"nextItem":{"title":"LIPS Scheme History","permalink":"/blog/lips-history"}},"content":"LIPS Scheme support regular expression literals, but it\'s not the only one implementation that\\nsupport those.  Other implementation includes [Gauche](https://practical-scheme.net/gauche/) and\\n[Kawa](https://www.gnu.org/software/kawa/index.html).\\n\\nUnfortunetlly, you can\'t easily use those regular expressions in [GNU\\nEmacs](https://en.wikipedia.org/wiki/GNU_Emacs), my main editor of choice.\\n\\n\x3c!--truncate--\x3e\\n\\n## The problem\\n\\nThe main problem is when using vertical bar character inside Scheme code in Emacs. GNU Emacs thinks\\nthat the vertical bar is part of the [symbol](/docs/scheme-intro/data-types#symbols):\\n\\n```scheme\\n(let ((str \\"foo bar\\")\\n      (re #/foo|bar/)) ;; | ))\\n  (str.match re))\\n;; ==> #(\\"foo\\")\\n```\\n\\nThis blog (the same as whole website) use modified PrismJS Scheme mode that supports regular\\nexpressions. But in GNU Emacs there was a need to add `|` after a comment and close the lists that\\nwere ignored by Emacs scheme mode (because they were inside symbol).\\n\\n## The solution\\n\\nI asked a [question on emacs-devel mailing\\nlist](https://lists.gnu.org/archive/html/emacs-devel/2024-02/msg00896.html), on how to solve this\\nproblem. I didn\'t get any reply for days, then suddenly someone [reply with this emacs lisp code\\nsnippet](https://lists.gnu.org/archive/html/emacs-devel/2024-03/msg00282.html).\\n\\n```lisp\\n(defun scheme-regex-patch ()\\n  (setq-local\\n   syntax-propertize-function\\n   (lambda (start end)\\n     (goto-char start)\\n     (funcall\\n      (syntax-propertize-rules\\n       ;; For #/regexp/ syntax\\n       (\\"\\\\\\\\(#\\\\\\\\)/\\\\\\\\(\\\\\\\\\\\\\\\\/\\\\\\\\|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|.\\\\\\\\)*?\\\\\\\\(/\\\\\\\\)\\"\\n        (1 \\"|\\")\\n        (3 \\"|\\"))\\n       ;; For #; comment syntax\\n       (\\"\\\\\\\\(#\\\\\\\\);\\"\\n        (1 (prog1 \\"< cn\\"\\n             (scheme-syntax-propertize-sexp-comment\\n              (point) end)))))\\n      (point) end))))\\n\\n(add-hook \'scheme-mode-hook \'scheme-regex-patch)\\n```\\n\\nThis solution worked great, until I\'ve found that it don\'t properly handle Scheme expression\\ncomments `#;`, that are part of the solution. In the meantime on the mailing list there was discussion\\nabout this feature (probably because it\'s part of GNU Kawa) to integrate with builtin `scheme.el`.\\nSo soon you may not need a hack like this when working with regular expressions.\\n\\nThis is a proposed solution after I said that the code doesn\'t work for Scheme expression comments.\\n\\n```lisp\\n(defun scheme-regex-patch ()\\n   (setq-local\\n    syntax-propertize-function\\n    (lambda (beg end)\\n      (goto-char beg)\\n      (scheme-syntax-propertize-sexp-comment2 end)\\n      (scheme-syntax-propertize-regexp end)\\n      (funcall\\n       (syntax-propertize-rules\\n        (\\"\\\\\\\\(#\\\\\\\\);\\" (1 (prog1 \\"< cn\\"\\n                         (scheme-syntax-propertize-sexp-comment2 end))))\\n        (\\"\\\\\\\\(#\\\\\\\\)/\\" (1 (when (null (nth 8 (save-excursion\\n                                            (syntax-ppss\\n                                             (match-beginning 0)))))\\n                         (put-text-property\\n                          (match-beginning 1)\\n                          (match-end 1)\\n                          \'syntax-table (string-to-syntax \\"|\\"))\\n                         (scheme-syntax-propertize-regexp end)\\n                         nil)\\n                       )))\\n       (point) end))))\\n\\n(defun scheme-syntax-propertize-sexp-comment2 (end)\\n  (let ((state (syntax-ppss)))\\n    (when (eq 2 (nth 7 state))\\n      ;; It\'s a sexp-comment.  Tell parse-partial-sexp where it ends.\\n      (condition-case nil\\n          (progn\\n            (goto-char (+ 2 (nth 8 state)))\\n            ;; FIXME: this doesn\'t handle the case where the sexp\\n            ;; itself contains a #; comment.\\n            (forward-sexp 1)\\n            (put-text-property (1- (point)) (point)\\n                               \'syntax-table (string-to-syntax \\"> cn\\")))\\n        (scan-error (goto-char end))))))\\n\\n(defun scheme-syntax-propertize-regexp (end)\\n  (let* ((state (syntax-ppss))\\n         (within-str (nth 3 state))\\n         (start-delim-pos (nth 8 state)))\\n    (when (and within-str\\n               (char-equal ?# (char-after start-delim-pos)))\\n      (while\\n          (and\\n           (re-search-forward \\"/\\" end \'move)\\n           (eq -1\\n               (% (save-excursion\\n                    (backward-char)\\n                    (skip-chars-backward \\"\\\\\\\\\\\\\\\\\\")) 2))))\\n      (when (< (point) end)\\n        (progn\\n          (put-text-property\\n           (match-beginning 0)\\n           (match-end 0)\\n           \'syntax-table (string-to-syntax \\"|\\")))))))\\n\\n(add-hook \'scheme-mode-hook \'scheme-regex-patch)\\n```\\n\\nYou can read the whole discussion on [emacs-devel mailing list archive](https://lists.gnu.org/archive/html/emacs-devel/2024-03/msg00590.html)."},{"id":"lips-history","metadata":{"permalink":"/blog/lips-history","editUrl":"https://github.com/LIPS-scheme/lips/tree/master/docs/blog/2024-03-03-lips-history.md","source":"@site/blog/2024-03-03-lips-history.md","title":"LIPS Scheme History","description":"This is the first article on LIPS blog. In this article I will write about the history of LIPS","date":"2024-03-03T00:00:00.000Z","tags":[{"inline":true,"label":"lips","permalink":"/blog/tags/lips"},{"inline":true,"label":"scheme","permalink":"/blog/tags/scheme"},{"inline":true,"label":"history","permalink":"/blog/tags/history"}],"readingTime":1.825,"hasTruncateMarker":true,"authors":[{"name":"Jakub T. Jankiewicz","title":"LIPS maintainer","url":"https://jakub.jankiewicz.org/","imageURL":"https://github.com/jcubic.png","key":"jcubic","page":null}],"frontMatter":{"slug":"lips-history","title":"LIPS Scheme History","authors":"jcubic","image":"/img/lips-history.png","tags":["lips","scheme","history"]},"unlisted":false,"prevItem":{"title":"Scheme Regex literals in Emacs","permalink":"/blog/emacs-scheme-regex"}},"content":"This is the first article on LIPS blog. In this article I will write about the history of LIPS\\nScheme interpreter.\\n\\n\x3c!--truncate--\x3e\\n\\n## What is Scheme?\\n\\nScheme is a dialect of the Lisp. The second oldest programming language still in use (after\\nFortran).  Lisp and Scheme have specific syntax with prefix notation and where everything is a list\\n(at least historically).  It\'s also [Homoiconic](https://en.wikipedia.org/wiki/Homoiconicity), which\\nmeans that code and data have the same represantion. This allows to write programs that modify the\\ncode like it was data.\\n\\n## What is LIPS?\\n\\nLIPS name is a recursive ancronym which stands for **\\"LIPS Is Pretty Simple\\"**. LIPS Scheme is\\nimplementation of Scheme programming language in JavaScript. It adds a lot of stuff on top of Scheme\\nto make it more powerful and easier to interact with JavaScript.\\n\\n## History of LIPS\\n\\nIt all started in February 2018 when I\'ve written the first version of a Lisp interpreter. You can\\nstill see the code on [CodePen](https://codepen.io/jcubic/pen/gvvzdp). Then I moved the [development\\nto GitHub](https://github.com/jcubic/lips) and named the project LIPS.  The first release (version\\n0.2.0) is marked as Mar 2018.\\n\\nThe reason why I created another lisp in JavaScript was because I wanted to have an Emacs in browser\\nthat would have a real lisp inside. That\'s why LIPS had dynamic scope as an option. GNU Emacs use\\nElisp that for a long time had dynamic scope. So I was planing to emulate that.\\n\\nAt the beginning it was Lisp based on Scheme, but at one point after version\\n[0.20.1 dated as Jul 1, 2020](https://github.com/jcubic/lips/releases/tag/0.20.1), I\'ve started\\nadding features on devel branch and decided that I want a full Scheme implementation. But it turns out\\nthat there were way too many breaking changes to release the next version. So I decided that I will\\nrelease it as 1.0-beta. Since then, LIPS keeps introducing new Beta versions. You can see the\\n[latest release on GitHub](https://github.com/jcubic/lips/releases).\\n\\n## Future of LIPS\\n\\nFor the future plans I want in final version 1.0 are implementation of continutations and Tail Calls\\n(<abbr title=\\"Tail Call Optimization\\">TCO</abbr>) and to be compatible (more or less) with\\n[R<sup>7</sup>RS specification](https://standards.scheme.org/). To see the progress, you can check\\n[1.0 Milestone on GitHub](https://github.com/jcubic/lips/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0)."}]}}')}}]);